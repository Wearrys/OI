% CSP 2019 模拟赛题解
% Wearry
% Stay determined!

Game
===

\qquad 考虑首先计算出不考虑要求最大字典序情形下的答案 $k$，
接下来按顺序考虑每一个位置填什么数能够使得分数尽可能高，
不难发现这样的数一定是单调的，因此具有可二分性。

\qquad 于是可以用线段树维护最大得分，
在每一位上二分，贪心地找到能够满足条件的最大的数即可。

Time
===

\qquad 考虑最小值所在的位置一定是在整个序列的开头或者末尾，
因此优先将最小值移动到序列的首部或者尾部后，
相当于转换成了一个规模更小的子问题，
于是对于最小值来说只需贪心地选择向左向右操作次数更少的方向即可。

Cover
===

\qquad 子区间之间只有相互包含和不交的关系，因此它们的包含关系会构成一棵树。

\qquad 首先考虑一个暴力的解法，
记 $f[i][j]$ 表示在 $i$ 为根的子树中点被覆盖的最多次数为 $j$ 的最优答案，
转移的时候首先将所有子树的答案直接合并，然后考虑点 $i$ 的贡献：

$$
f[i][j] = \max\{f[i][j], f[i][j-1] + a[i]\}
$$

\qquad 不难发现可以维护 $f[i]$ 的差分表，
则 $f[i]$ 的差分表一定单调，
则合并子树相当于将差分表对应相加，
点 $i$ 的贡献则相当于将 $a[i]$ 按照大小顺序插入差分表。
